#sum of squaried error
#head(df)
MSE_mean <- mean((df$flow - df$mean)^2)
ME_median <- mean(abs(df$flow-df$median))
print(paste("MSE of the mean model is:",MSE_mean))
print(paste("ME of the median model is",ME_median))
#estimate 75% quantile
q75 <- rqss(data=df,flow ~ qss(day,lambda=50),tau = 0.75)
q75_pred <- predict(q75,newdata = df)
df <- df %>% mutate(q75 = q75_pred[,1])
head(df)
#plot
p <- ggplot(data = df)+
geom_point(aes(day,flow),alpha = 0.3) +
geom_line(aes(x=day,y=mean,color="Mean"),size=1) +
geom_line(aes(x=day,y=median, color="Median"),size=1)+
geom_line(aes(x=day,y=q75, color="75-Quantile"),size=1)+
guides(colour=guide_legend("Model"))+
labs(x="Day of Year",y="Flow")+
ggtitle("Mean vs Median vx 75-Quantile")
plot(p)
day_160 <- unique(df %>% filter(day==160) %>% select(q75))[1,1]
print(paste("the estimate of day 160 is", day_160))
df <- df %>% mutate(q75_error = flow - q75)
tau = 0.75
head(df)
df <- df %>% mutate(score = ifelse(q75_error>=0.0, q75_error*tau,q75_error*(tau-1)))
sum_scores <- sum(df$score)
print(paste("the error of this model is",sum_scores))
#estimate 95% quantile
q95 <- rqss(data=df,flow~qss(day,lambda=50),tau = 0.95)
q95_pred <- predict(q95,newdata = df)
df <- df %>% mutate(q95 = q95_pred[,1])
#head(df)
#estimate 5% quantile
q5 <- rqss(data=df,flow ~ qss(day,lambda=50),tau = 0.05)
q5_pred <- predict(q5,newdata = df)
df <- df %>% mutate(q5 = q5_pred[,1])
#head(df)
#plot
ggplot(data = df)+
geom_line(aes(day,flow),alpha = 0.3) +
geom_line(aes(x=day,y=q95),color="blue",size=1) +
geom_line(aes(x=day,y=q5), color="blue",size=1)+
labs(x="Day of Year",y="Flow")+
ggtitle("90% prediction interval")
day_160_95 <- unique(df %>% filter(day==160) %>% select(q95))[1,1]
day_160_5 <- unique(df %>% filter(day==160) %>% select(q5))[1,1]
print(paste("the upper bound of 90% prediction interval is", day_160_95))
print(paste("the lower bound of 90% prediction interval is", day_160_5))
#plot density estimate of day 160
dat_160 <- df %>% filter(day == 160)
d_160 <- density(dat_160$flow)
#plot(d_160)
#plot density estimate of day 300
dat_300 <- df %>% filter(day==300)
d_300 <- density(dat_300$flow)
#plot(d_300)
#plot
plot(d_160, xlim=c(0,400),ylim=c(0,0.1),col = "blue", xlab = "Flow", ylab = "Density",main="Density Estimates")
lines(d_300,xlim=c(0,400),ylim=c(0,0.1),col="red")
legend("topright",
legend = c("day 300","day 160"),
col = c("red","blue"),
lty = c(1,1))
df2 <- data
#get mean of log flow
loe_log <- loess(log(flow)~day,data=df2,span=0.2) %>%
predict()
df2 <- df2 %>% mutate(flow_log = loe_log)
#get variance of log flow
var_log <- df2 %>% loess(formula = (log(flow)-flow_log)^2~day,span=0.2) %>%
predict()
df2 <- df2 %>% mutate(flow_var_log = var_log)
head(df2)
#plot
df2 %>% ggplot(aes(x=day,group=year)) +
geom_point(aes(y=log(flow)),alpha=0.2) +
geom_line(aes(y=flow_log,color="LogOfFlow"),size=1)+
geom_line(aes(y=flow_log + 1.64*sqrt(flow_var_log),color="UpperBondof90%Interval"),size=1.5)+
geom_line(aes(y=flow_log - 1.64*sqrt(flow_var_log),color="LowerBondof90%Interval"),size=1.5) +
scale_discrete_manual(aesthetics = "color", values = c("LogOfFlow"="red","UpperBondof90%Interval"="blue", "LowerBondof90%Interval"="blue")) +
ggtitle("Log FLow Variance Regression")+
guides(color=guide_legend("Legend"))
log_mean_160 <- unique(df2 %>% filter(day ==160) %>% select(flow_log))[1,1]
log_var_160 <- unique(df2 %>% filter(day==160) %>% select(flow_var_log))[1,1]
median <-qlnorm(0.5,meanlog = log_mean_160, sdlog = sqrt(log_var_160))
print(paste("median on day 160:", median))
Q3 <- qlnorm(0.75,meanlog = log_mean_160,sdlog = sqrt(log_var_160))
Q1 <- qlnorm(0.25,meanlog = log_mean_160,sdlog = sqrt(log_var_160))
print(paste("interquartile range is",Q3-Q1))
r <- 10
datsub <- filter(df2,(day>=160-r & day<=160+r) | (day>=300-r & day<=300+r)) %>%
mutate(approx_days = if_else(day>=160-r & day<=160+r, 160, 300))
datsub %>% group_by(approx_days) %>%
summarize(expected_flow=round(mean(flow))) %>%
select(day=approx_days, expected_flow)
datsub
ggplot(datsub, aes(flow)) +
geom_density(aes(fill=factor(approx_days)), colour=NA, alpha=0.5) +
scale_fill_discrete("Days (X)") +
theme_bw() +
xlab("Flows (Y)")+ggtitle ('The probabilistic flow rate for days 160 and 300' )
crime <- read.dta("https://stats.idre.ucla.edu/stat/data/crime.dta")
head(crime)
pl <- ggplot(data = crime,aes(murder,crime))+
geom_point()+
ggtitle("Murders vs Crimes") +
labs(x="Number of Murders", y="Number of Crimes")
linear <- lm(crime~murder,data=crime)
plot(linear,which=4)
#rob <- lmRob(crime~murder, crime)
pl+
geom_smooth(method = "lmRob", se=FALSE,aes(color = "Robust Linear")) +
geom_smooth(method = "lm",se=FALSE,aes(color = "Regular Linear")) +
geom_quantile(quantiles = 0.5,aes(color="Linear Median"))+
labs(title="Crime data with 3 Model Functions") +
guides(color = guide_legend("Regression models"))
setwd("~/block5/KMediansR")
distance <- function(X, medians){
# Calculates the Manhanttan distance between the medians and every point in the dataset
#
# Parameters
# ----------
# x: matrix
# The dataset being clustered
#
# medians: matrix
# Medians of the clusters
#
# Returns
# -------
# dist: matrix
# Distance between each point and each median
K = nrow(medians)
n = nrow(X)
dist<- matrix(nrow=n,ncol=K)
for (k in 1:K) {
for (i in 1:n){
dist[i,k] <- abs(X[i,1]-medians[k,1])+abs(X[i,2]-medians[k,2])
}
}
return (dist)
}
A<-matrix(c(1,2,3,4,5,6,7,8),
nrow = 4,
ncol = 2,
byrow = TRUE)
m<-matrix(c(1,1,2,2,3,3),
nrow = 3,
ncol=2,
byrow = TRUE)
distance(A,m)
kmedians <- function(X, num_clusters){
# Groups the points in your dataset ,X, into the desired number of clusters, based on the median distance between the points.
# This function uses random intilization to assign the first medians and then will update the medians and
# the group assignments until the assignment does not change.
#
# Parameters
# ----------
# X: matrix
# The dataset being clustered
#
# num_clusters: integer
# The desired number of clusters
#
# Returns
# -------
# List contains both medians and labels :
#
#   medians: matrix
#   The coordinates of the medians for each cluster
#
#   labels: list
#   List that has the assignment of the cluster for each point in the dataset
set.seed(123)
n <- nrow(X)
u <- matrix(0, nrow = num_clusters, ncol = n)
# initialize median points
medians <- X[sample(n,size=num_clusters,replace=FALSE),]
for (i in 1:n_it){
K <- nrow(medians)
N <- nrow(X)
dist <- matrix(nrow=N,ncol=K)
for (k in 1:K) {
for (i in 1:n){
dist[i,k] <- abs(X[i,1]-medians[k,1])+abs(X[i,2]-medians[k,2])
}
}
labels <- apply(dist, 1, which.min)
for (j in 1:n){
u[labels[j], j] <- 1
}
for (k in 1:num_clusters){
medians[k,] = apply((matrix(X[u[k,]==1],ncol=2)), 2, median)
}
}
# make the output as a list
return(list(medians,labels))
}
}
kmedians <- function(X, num_clusters){
# Groups the points in your dataset ,X, into the desired number of clusters, based on the median distance between the points.
# This function uses random intilization to assign the first medians and then will update the medians and
# the group assignments until the assignment does not change.
#
# Parameters
# ----------
# X: matrix
# The dataset being clustered
#
# num_clusters: integer
# The desired number of clusters
#
# Returns
# -------
# List contains both medians and labels :
#
#   medians: matrix
#   The coordinates of the medians for each cluster
#
#   labels: list
#   List that has the assignment of the cluster for each point in the dataset
set.seed(123)
n <- nrow(X)
u <- matrix(0, nrow = num_clusters, ncol = n)
# initialize median points
medians <- X[sample(n,size=num_clusters,replace=FALSE),]
for (i in 1:n_it){
K <- nrow(medians)
N <- nrow(X)
dist <- matrix(nrow=N,ncol=K)
for (k in 1:K) {
for (i in 1:n){
dist[i,k] <- abs(X[i,1]-medians[k,1])+abs(X[i,2]-medians[k,2])
}
}
labels <- apply(dist, 1, which.min)
for (j in 1:n){
u[labels[j], j] <- 1
}
for (k in 1:num_clusters){
medians[k,] = apply((matrix(X[u[k,]==1],ncol=2)), 2, median)
}
}
# make the output as a list
return(list(medians,labels))
}
summary <- function(X, medians, labels){
# Generates a table to display the cluster labels, the coordinates of the cluster medians,
# number of points in each cluster, the average distance within the cluster,
# the maximum distance within the cluster and the minimum distance within the cluster.
#
#
# Parameters
# ----------
#
# X: matrix
# The dataset being clustered
#
# medians: matrix
# Coordinates of each cluster median
#
# labels:  list
# Array with the assignment of the cluster for each point in the dataset
#
# Returns
# -------
# dataframe
# Returns a dataframe with 6 columns and number of rows will be the number of clusters. The labels of the columns:
# Cluster labels, Median Coordinates, Number of Points in Cluster, Average Distance, Minimum Distance, Maximum Distance
medians_df <- data.frame(cbind(unique(labels),medians)) %>%
plyr::rename(c(X1 = 'label', X2 = 'medianX', X3 = 'medianY'))
summary_df <- data.frame(cbind(A,labels)) %>%
plyr::rename(c(V1 = 'X', V2 = 'Y', labels = 'label')) %>%
dplyr::right_join(medians_df, by = 'label') %>%
dplyr::mutate(distance = (abs(X-medianX)+abs(Y-medianY))) %>%
dplyr::select(label, medianX, medianY, distance) %>%
dplyr::group_by(label) %>%
dplyr::summarise(medianX = unique(medianX), medianY = unique(medianY), num = n(), avgd = mean(distance), mind = min(distance), maxd = max(distance)) %>%
dplyr::mutate(med = paste(medianX, medianY, sep = ",")) %>%
dplyr::arrange(label) %>%
dplyr::select(label, med, num, avgd, mind, maxd) %>%
plyr::rename(c(label = 'Cluster Label',
med = 'Median Coordinates',
num = 'Number of Points in Cluster',
avgd = 'Average Distance',
mind = 'Minimum Distance',
maxd = 'Maximum Distance'))
return (data.frame(summary_df))
}
crime <- read.dta("https://stats.idre.ucla.edu/stat/data/crime.dta")
library(tidyverse)
crime <- read.dta("https://stats.idre.ucla.edu/stat/data/crime.dta")
suppressPackageStartupMessages(library(foreign))  # For read.dta()
library(tidyverse)
library(quantreg)
library(broom)
library(robust)
library(ggplot2)
crime <- read.dta("https://stats.idre.ucla.edu/stat/data/crime.dta")
df <- crime %>% select(crime, murder)
df
distance(df,2)
df <- as.matrix(df)
df
distance(df,2)
m<-matrix(c(1,1,2,2,3,3),
nrow = 3,
ncol=2,
byrow = TRUE)
distance(df,m)
library(flexclust)
dist2(df,m,"man")
d <- distance(df,m)
d2 <- dist2(df,m,"man")
d-df
d-d2
kmedians(df,2)
kmedians <- function(X, num_clusters,n_it=100){
# Groups the points in your dataset ,X, into the desired number of clusters, based on the median distance between the points.
# This function uses random intilization to assign the first medians and then will update the medians and
# the group assignments until the assignment does not change.
#
# Parameters
# ----------
# X: matrix
# The dataset being clustered
#
# num_clusters: integer
# The desired number of clusters
#
# Returns
# -------
# List contains both medians and labels :
#
#   medians: matrix
#   The coordinates of the medians for each cluster
#
#   labels: list
#   List that has the assignment of the cluster for each point in the dataset
set.seed(123)
n <- nrow(X)
u <- matrix(0, nrow = num_clusters, ncol = n)
# initialize median points
medians <- X[sample(n,size=num_clusters,replace=FALSE),]
for (i in 1:n_it){
K <- nrow(medians)
N <- nrow(X)
dist <- matrix(nrow=N,ncol=K)
for (k in 1:K) {
for (i in 1:n){
dist[i,k] <- abs(X[i,1]-medians[k,1])+abs(X[i,2]-medians[k,2])
}
}
labels <- apply(dist, 1, which.min)
for (j in 1:n){
u[labels[j], j] <- 1
}
for (k in 1:num_clusters){
medians[k,] = apply((matrix(X[u[k,]==1],ncol=2)), 2, median)
}
}
# make the output as a list
return(list(medians,labels))
}
kmedians(df,2)
summary(df,medians,labels)
medians,labels <- kmedians(df,2)
medians <- list()
labels <- list()
medians,labels <- kmedians(df,2)
ml <- kmedians(df,2)
ml
summary(df, ml[[1]],ml[[2]])
ml[1]
summary(df,ml[1],ml[2])
ml[[1]]
is.matrix(ml[[1]])
is.list(ml[[2]])
is.matrix(ml[[2]])
ml[[2]]
is.vector(ml[[2]])
summary(df,ml[[2]],ml[[1]])
summary(df,ml[[1]],ml[[2]])
summary <- function(X, medians, labels){
# Generates a table to display the cluster labels, the coordinates of the cluster medians,
# number of points in each cluster, the average distance within the cluster,
# the maximum distance within the cluster and the minimum distance within the cluster.
#
#
# Parameters
# ----------
#
# X: matrix
# The dataset being clustered
#
# medians: matrix
# Coordinates of each cluster median
#
# labels:  list
# Array with the assignment of the cluster for each point in the dataset
#
# Returns
# -------
# dataframe
# Returns a dataframe with 6 columns and number of rows will be the number of clusters. The labels of the columns:
# Cluster labels, Median Coordinates, Number of Points in Cluster, Average Distance, Minimum Distance, Maximum Distance
medians_df <- data.frame(cbind(unique(labels),medians))
colnames(medians_df) <- c("label", "medianX", "medianY")
summary_df <- data.frame(cbind(A,labels))
colnames(summary_df) <- c("X","Y","label")
summary_df <- summary_df %>%
dplyr::right_join(medians_df, by = 'label') %>%
dplyr::mutate(distance = (abs(X-medianX)+abs(Y-medianY))) %>%
dplyr::select(label, medianX, medianY, distance) %>%
dplyr::group_by(label) %>%
dplyr::summarise(medianX = unique(medianX), medianY = unique(medianY), num = n(), avgd = mean(distance), mind = min(distance), maxd = max(distance)) %>%
dplyr::mutate(med = paste(medianX, medianY, sep = ",")) %>%
dplyr::arrange(label) %>%
dplyr::select(label, med, num, avgd, mind, maxd)
colnames(summary_df) <- c("Cluster Label","Median Coordinates",
"Number of Points in Cluster","Average Distance",
"Minimum Distance","Maximum Distance")
return (data.frame(summary_df))
}
summary(df,ml[[1]],ml[[2]])
summary <- function(X, medians, labels){
# Generates a table to display the cluster labels, the coordinates of the cluster medians,
# number of points in each cluster, the average distance within the cluster,
# the maximum distance within the cluster and the minimum distance within the cluster.
#
#
# Parameters
# ----------
#
# X: matrix
# The dataset being clustered
#
# medians: matrix
# Coordinates of each cluster median
#
# labels:  list
# Array with the assignment of the cluster for each point in the dataset
#
# Returns
# -------
# dataframe
# Returns a dataframe with 6 columns and number of rows will be the number of clusters. The labels of the columns:
# Cluster labels, Median Coordinates, Number of Points in Cluster, Average Distance, Minimum Distance, Maximum Distance
medians_df <- data.frame(cbind(unique(labels),medians))
colnames(medians_df) <- c("label", "medianX", "medianY")
summary_df <- data.frame(cbind(X,labels))
colnames(summary_df) <- c("X","Y","label")
summary_df <- summary_df %>%
dplyr::right_join(medians_df, by = 'label') %>%
dplyr::mutate(distance = (abs(X-medianX)+abs(Y-medianY))) %>%
dplyr::select(label, medianX, medianY, distance) %>%
dplyr::group_by(label) %>%
dplyr::summarise(medianX = unique(medianX), medianY = unique(medianY), num = n(), avgd = mean(distance), mind = min(distance), maxd = max(distance)) %>%
dplyr::mutate(med = paste(medianX, medianY, sep = ",")) %>%
dplyr::arrange(label) %>%
dplyr::select(label, med, num, avgd, mind, maxd)
colnames(summary_df) <- c("Cluster Label","Median Coordinates",
"Number of Points in Cluster","Average Distance",
"Minimum Distance","Maximum Distance")
return (data.frame(summary_df))
}
summary(df,ml[[1]],ml[[2]])
nrow(df)
summary <- function(X, medians, labels){
# Generates a table to display the cluster labels, the coordinates of the cluster medians,
# number of points in each cluster, the average distance within the cluster,
# the maximum distance within the cluster and the minimum distance within the cluster.
#
#
# Parameters
# ----------
#
# X: matrix
# The dataset being clustered
#
# medians: matrix
# Coordinates of each cluster median
#
# labels:  list
# Array with the assignment of the cluster for each point in the dataset
#
# Returns
# -------
# dataframe
# Returns a dataframe with 6 columns and number of rows will be the number of clusters. The labels of the columns:
# Cluster labels, Median Coordinates, Number of Points in Cluster, Average Distance, Minimum Distance, Maximum Distance
medians_df <- data.frame(cbind(unique(labels),medians))
colnames(medians_df) <- c("label", "medianX", "medianY")
summary_df <- data.frame(cbind(X,labels))
colnames(summary_df) <- c("X","Y","label")
summary_df <- summary_df %>%
dplyr::right_join(medians_df, by = 'label') %>%
dplyr::mutate(distance = (abs(X-medianX)+abs(Y-medianY))) %>%
dplyr::select(label, medianX, medianY, distance) %>%
dplyr::group_by(label) %>%
dplyr::summarise(medianX = unique(medianX), medianY = unique(medianY), num = n(), avgd = mean(distance), mind = min(distance), maxd = max(distance)) %>%
dplyr::mutate(med = paste(medianX, medianY, sep = ",")) %>%
dplyr::arrange(label) %>%
dplyr::select(label, med, num, avgd, mind, maxd)
colnames(summary_df) <- c("Cluster Label","Median Coordinates",
"Number of Points in Cluster","Average Distance",
"Minimum Distance","Maximum Distance")
return (print_screen(data.frame(summary_df)))
}
summary(df,ml[[1]],ml[[2]])
